import { readdirSync, readFileSync, writeFileSync } from "fs";
import { join } from "path";

// Read all partials
const partialsDir = join(process.cwd(), "prompts", "partials");
const partials: Record<string, string> = {};

for (const file of readdirSync(partialsDir)) {
  if (file.endsWith(".md")) {
    const name = file.replace(".md", "");
    partials[name] = readFileSync(join(partialsDir, file), "utf-8");
  }
}

// Function to replace partials in content
function replacePartials(content: string): string {
  return content.replace(/\{>([a-zA-Z0-9_-]+)\}/g, (match, partialName) => {
    const partial = partials[partialName];
    if (!partial) {
      console.warn(`Warning: Partial '${partialName}' not found`);
      return match;
    }
    return partial;
  });
}

// Special handling for known optional sections
const OPTIONAL_SECTIONS: Record<string, string> = {
  previousClarifications: `
## Previous Clarifications

The user has already provided these answers:

{previousClarifications}
`,
};

// Function to convert markdown to TypeScript function
function generateFunction(
  name: string,
  content: string,
  variables: { name: string; optional: boolean }[],
): string {
  // Replace partials first
  content = replacePartials(content);

  // Escape backticks and ${ for template literals
  content = content.replace(/`/g, "\\`").replace(/\$\{/g, "\\${");

  // Handle optional sections
  for (const [varName, section] of Object.entries(OPTIONAL_SECTIONS)) {
    const escapedSection = section
      .replace(/`/g, "\\`")
      .replace(/\$\{/g, "\\${")
      .replace(/\{([a-zA-Z0-9_-]+)\}/g, "${vars.$1}");

    content = content.replace(
      new RegExp(`\\{${varName}\\}`, "g"),
      `\${vars.${varName} ? \`${escapedSection}\` : ""}`,
    );
  }

  // Replace remaining {variableName} placeholders
  content = content.replace(/\{([a-zA-Z0-9_-]+)\}/g, "${vars.$1}");

  // Generate interface
  const interfaceProps = variables
    .map((v) => `  ${v.name}${v.optional ? "?" : ""}: string;`)
    .join("\n");

  const interfaceName = toPascalCase(name) + "Vars";

  return `
export interface ${interfaceName} {
${interfaceProps}
}

export function ${name}(vars: ${interfaceName}): string {
  return \`${content}\`;
}
`;
}

function toPascalCase(str: string): string {
  return str
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");
}

// Read and process each prompt
const promptsDir = join(process.cwd(), "prompts");
const promptFiles: Array<{
  name: string;
  content: string;
  vars: Array<{ name: string; optional: boolean }>;
}> = [
  {
    name: "buildValidationPrompt",
    content: readFileSync(
      join(promptsDir, "validate-requirements.md"),
      "utf-8",
    ),
    vars: [
      { name: "userPrompt", optional: false },
      { name: "previousClarifications", optional: true },
    ],
  },
  {
    name: "buildPlanningPrompt",
    content: readFileSync(join(promptsDir, "plan-exercises.md"), "utf-8"),
    vars: [{ name: "requirements", optional: false }],
  },
  {
    name: "buildGenerationPrompt",
    content: readFileSync(join(promptsDir, "generate-exercises.md"), "utf-8"),
    vars: [
      { name: "requirements", optional: false },
      { name: "approvedPlan", optional: false },
      { name: "exerciseItem", optional: false },
    ],
  },
];

// Generate output
let output = `// Auto-generated from markdown files in prompts/
// Run: pnpm build:prompts
// DO NOT EDIT THIS FILE DIRECTLY - Edit the markdown files instead

`;

for (const { name, content, vars } of promptFiles) {
  output += generateFunction(name, content, vars);
}

// Write output
const outputPath = join(process.cwd(), "convex", "_generated_prompts.ts");
writeFileSync(outputPath, output, "utf-8");

console.log(`âœ“ Generated prompts from ${promptFiles.length} markdown files`);
console.log(`  Output: convex/_generated_prompts.ts`);
