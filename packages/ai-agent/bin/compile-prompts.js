#!/usr/bin/env node
/* Minimal compile-prompts implementation
   - Reads files from src/prompts/*.{md,yml,yaml,json}
   - Parses frontmatter (YAML) and body
   - Emits TypeScript modules to dist/generated/
   - Emits Zod schemas for runtime validation
*/
const fs = require("fs");
const path = require("path");
const yaml = require("js-yaml");

const ROOT = path.resolve(__dirname, "..");
const PROMPTS_DIR = path.join(ROOT, "src", "prompts");
const OUT_DIR = path.join(ROOT, "dist", "generated");

function readFiles(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  const files = [];
  for (const e of entries) {
    if (e.isFile() && /\.(md|yaml|yml|json)$/i.test(e.name))
      files.push(path.join(dir, e.name));
  }
  return files;
}

function parseFile(file) {
  const text = fs.readFileSync(file, "utf8");
  if (/^\s*\{/m.test(text)) {
    // JSON
    try {
      return JSON.parse(text);
    } catch (err) {
      throw new Error("Invalid JSON in " + file + ": " + err.message);
    }
  }

  if (/^---\s*\n/.test(text)) {
    const parts = text.split(/^---\s*\n/m).slice(1);
    // parts[0] = frontmatter until next ---
    const restIndex = text.indexOf("\n---", 3);
    // naive: find second ---
    const match = text.match(/^---\s*\n([\s\S]*?)\n---\s*\n?/m);
    if (match) {
      const fm = match[1];
      const body = text.slice(match[0].length);
      const data = yaml.load(fm) || {};
      if (typeof data === "object") {
        data._body = body.trim();
        return data;
      }
    }
  }

  // fallback: treat whole file as skill prompt body
  return {
    type: "skill",
    id: path.basename(file, path.extname(file)),
    _body: text.trim(),
  };
}

function ensureOut() {
  fs.mkdirSync(OUT_DIR, { recursive: true });
}

function generateTS(toolRegistry, skillRegistry) {
  const toolTs = `// Generated by @package/ai-agent compile-prompts
import { z } from 'zod';

export const toolRegistry = ${JSON.stringify(toolRegistry, null, 2)} as const;

export type ToolRegistry = typeof toolRegistry;

export const toolArgSchema = z.object({
  name: z.string(),
  type: z.string(),
  required: z.boolean().optional(),
  description: z.string().optional(),
  default: z.any().optional(),
});

export const toolSchema = z.object({
  description: z.string(),
  args: z.array(toolArgSchema).optional(),
});

export const toolRegistrySchema = z.record(toolSchema);
`;

  const skillTs = `// Generated by @package/ai-agent compile-prompts
import { z } from 'zod';

export const skillRegistry = ${JSON.stringify(skillRegistry, null, 2)} as const;

export type SkillRegistry = typeof skillRegistry;

export const skillSchema = z.object({
  prompt: z.string(),
  metadata: z.record(z.any()).optional(),
});

export const skillRegistrySchema = z.record(skillSchema);
`;

  return { toolTs, skillTs };
}

function main() {
  if (!fs.existsSync(PROMPTS_DIR)) {
    console.error("No prompts dir at", PROMPTS_DIR);
    process.exit(1);
  }

  const files = readFiles(PROMPTS_DIR);
  const toolRegistry = {};
  const skillRegistry = {};

  for (const f of files) {
    const data = parseFile(f);
    const type = data.type || "skill";
    const id = data.id || path.basename(f, path.extname(f));

    if (type === "tool") {
      const description = data.description || data._body || "";
      const args = Array.isArray(data.args) ? data.args : [];
      toolRegistry[id] = { description, args };
    } else if (type === "skill") {
      const prompt = data._body || data.prompt || "";
      const metadata = { ...(data.metadata || {}) };
      skillRegistry[id] = { prompt, metadata };
    } else {
      console.warn("Unknown prompt type", type, "in", f);
    }
  }

  ensureOut();
  const { toolTs, skillTs } = generateTS(toolRegistry, skillRegistry);
  fs.writeFileSync(path.join(OUT_DIR, "tool-registry.ts"), toolTs, "utf8");
  fs.writeFileSync(path.join(OUT_DIR, "skill-registry.ts"), skillTs, "utf8");

  console.log("Wrote", OUT_DIR);
}

if (require.main === module) main();
